#!/bin/bash
typeset -gx THIS=$(readlink -fn ${0})
# !!! DO NOT TOUCH !!!
typeset -gix db_status=$((0xDEAD))
# ---------------------

# use colored output if supported
function use_colors() {
	case $1 in
		yes)
			typeset -gx blue
			typeset -gx green
			typeset -gx red
			typeset -gx orange
			typeset -gx bold
			typeset -gx sgr0
			if [[ $TERM =~ ^.*[1-9]{2,3}(bit|color)$ ]]; then
				sgr0="\x1b(B\x1b[m"
				bold="\x1b[1m"
				orange="\x1b[38;2;255;115;0m"
				red="x1b[38;2;255;0;50m"
				green="\x1b[38;2;110;255;0m"
				blue="\x1b[38;2;0;110;255m"
			fi
			;;
		no)
			unset blue
			unset green
			unset red
			unset orange
			unset bold
			unset sgr0
			;;
	esac
	return
}

# print help
function print_help() {
	printf '%b' "${bold}${blue}Usage:\n${sgr0}"
	printf '%b' "\t${bold}${green}$(basename ${THIS}) ${sgr0}"
	printf '%b' "${bold}${orange}OPTION ${sgr0}"
	printf '%b' "${orange}[ARG]${sgr}\n\n"
	printf '%b' "${bold}${orange}OPTION${sgr0} may be:\n"
	printf '%b' "\t${blue}-c|--create${sgr0}\t"
	printf '%b' "create the internal database. (implicit destroy)\n"
	printf '%b' "\t${blue}-g|--generate${sgr0}\t"
	printf '%b' "create a SIGNINGKEY in current directory.\n"
	printf '%b' "\t${blue}-h|--help${sgr0}\t"
	printf '%b' "print this help.\n"
	printf '%b' "\t${blue}-i|--import${sgr0} "
	printf '%b' "${orange}SIGNINGKEY${sgr0}\t"
	printf '%b' "export an existing SIGNINGKEY"
	printf '%b' "to the database. (requires empty database)\n"
	printf '%b' "\t${blue}-r|--reset${sgr0}\t"
	printf '%b' "destroy the saved blob and"
	printf '%b' "reset the database.\n"
	printf '%b' "\t${blue}-s|--sign${sgr0}"
	printf '%b' "${orange}MODULEFILE${sgr0}\t"
	printf '%b' "sign MODULEFILE with the SIGNINGKEY"
	printf '%b' "stored in the database.\n\n\n"
	return $?
}

# create the internal database
function db_create() {
	if [[ ${db_status} -ne $((0xDEAD)) ]]; then
		db_destroy
	fi
	if [[ $? -eq 0 ]]; then
		sqlite3 --append ${THIS} \
			"CREATE TABLE keydb (
		key_id INTEGER NOT NULL PRIMARY KEY,
		key_name TEXT NOT NULL,
		key_data BLOB);" &>/dev/zero && sed \
			's%^typeset db_status=$((0xDEAD))$%typeset db_status=$((0x10AD))%' \
			-i ${THIS}
		printf '%b' "\n\tcreate :${green} SUCCESS${sgr0}\n"
	else
		printf '%b' "\n\tcreate :${red} FAILURE${sgr0}\n"
		return 1
	fi
	return $?
}

# remove the appended database
function db_destroy() {
	local -i PRE=$(stat -c %b ${THIS})
	sed '/^0x0ff5e7$/q' ${THIS} | dd | dd of=${THIS}
	local -i CUR=$(stat -c %b ${THIS})
	if [[ ${PRE} -gt ${CUR} && ${CUR} -gt 0 ]]; then
		sed 's%^typeset db_status=[0-9]*$%typeset db_status=$((0x10AD))%' \
			-i ${THIS}
		printf '%b' "\n\tdestroy :{green} SUCCESS${sgr0}\n"
		return 0
	else
		printf '%b' "\n\tdestroy :{red} FAILURE${sgr0}\n"
		return 1
	fi
}

# create the database and store the key as blob
function db_import() {
	if [[ ${db_status} -eq $((0xDEAD)) ]]; then
		printf '%b' "\n\timport :${blue} database ${red} offline${sgr0}\n"
		return 1
	elif [[ ${db_status} -eq $((0x10AD)) ]]; then
		sqlite3 ${THIS} \
			"INSERT INTO keydb (key_id,key_name,key_data)
			 VALUES ($((0XB10B)),'$(basename ${1})',readfile('${1}'));" \
			&>/dev/zero && sed \
			's%^typeset db_status=$((0x10AD))$%typeset db_status=$((0xC0DE))%' \
			-i ${THIS}
		return $?
	elif [[ ${db_status} -eq $((0xC0DE)) ]]; then
		printf '%b' "\n\timport :${blue} database${red} NOT${sgr0}${blue} empty${sgr0}\n"
		return 1
	fi
}

function db_select() {
	if [[ ${db_status} -eq $((0xC0DE)) ]]; then
		local EXPORTDIR=$(mktemp --directory /tmp/.XXXXXX)
		local EXPORTKEY=$(mktemp ${EXPORTDIR}/.XXXXXX)
		sqlite3 ${THIS} \
			"SELECT writefile('${EXPORTKEY}',key_data)
			 FROM keydb
			 WHERE key_id = $((0xB10B));" &>/dev/zero \
			&& typeset -gx EXPORTDIR
	elif [[ ${db_status} -eq $((0x10AD)) ]]; then
		printf '%b' "\n\tselect :${blue} database is${green} ONLINE"
		printf '%b' "${blue}, but ${red}NO KEYS${blue} available${sgr0}\n"
		return 1
	else
		printf '%b' "\n\tselect :${red} ENOENT: no database\n"
		return 1
	fi
}

function sign_module() {
	openssl pkey -in ${EXPORTDIR}/.* -out ${EXPORTDIR}/KEY
	openssl x509 -outform der -in ${EXPORTDIR}/.* -out ${EXPORTDIR}/CRT

}

# create the signing_key.pem
function generate_key() {
	local SIGNINGKEY=$(mktemp /tmp/.XXXXXX)
	local X509GENKEY=$(mktemp /tmp/.XXXXXX)
	printf '[ req ]
default_bits = 4096
distinguished_name = req_distinguished_name
prompt = no
string_mask = utf8only
x509_extensions = trusted_modules

[ req_distinguished_name ]
O = Tux Inc.
CN = Tux own trusted kernel key

[ trusted_modules ]
basicConstraints=critical,CA:FALSE
keyUsage=digitalSignature
subjectKeyIdentifier=hash
authorityKeyIdentifier=keyid
' >${X509GENKEY}
	openssl req -new -nodes \
		-utf8 -sha512 -day 65535 -batch \
		-x509 -config ${X509GENKEY} \
		-outform PEM -out ${SIGNINGKEY} \
		-keyout ${SIGNINGKEY} &>/dev/zero \
		&& mv --backup ${SIGNINGKEY} 'signing_key.pem' \
		&& rm -f ${X509GENKEY} \
		&& printf '%b' "\n\tgenerated :${sgr0}${bold} signing_key.pem${sgr0}\n"
	return $?
}

# check parameters, call subroutine
function start() {
	typeset -i N
	typeset -a PARAM=($(getopt -au \
		-o 'cdghri:s:' \
		-l 'create destroy genkey help import sign' -- $@ \
		| awk -F'--' '{print $1 }'))
	N=${#PARAM[@]}
	if [[ $N -ne 0 ]]; then
		N=0
		while [[ $N -lt ${#PARAM[@]} ]]; do
			case ${PARAM[$N]} in
				-c | --create)
					db_create
					return $?
					;;
				-d | --destroy)
					db_destroy
					return $?
					;;
				-g | --genkey)
					generate_key
					return $?
					;;
				-h | --help)
					print_help
					return $?
					;;
				-i | --import)
					N=$((N + 1))
					db_import ${PARAM[$N]}
					return $?
					;;
				-s | --sign)
					N=$((N + 1))
					db_select
					sign_module ${PARAM[$N]} || return 1
					;;
			esac
			N=$((N + 1))
		done
		return 0
	fi
	printf '%b' "${red}- wrong usage -${sgr0}\n"
	printf '%b' "check -h/--help for more.\n"
	return 1
}

use_colors yes
start $@
EXIT=$?
use_colors no
exit $EXIT
# -----------------------------------------------------------------------------
0x0ff5e7
# -----------------------------------------------------------------------------
